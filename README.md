
## pipex  
Linux 쉘에서 주로 사용되는 명령어 파이프라인을 구현하는 과제입니다.  
필수 과제와 추가 과제는 아래와 같이 구분됩니다.

### 필수 과제  

예를 들어 아래와 같이 인자가 들어왔을 때:  
~~~
./pipex file1 cmd1 cmd2 file2
~~~

이 shell command와 정확하게 동일한 행동을 해야 합니다:  
~~~
$> < file1 cmd1 | cmd2 > file2
~~~

### 추가 과제  
1. **Handling multiple pipes.**

인자가 아래와 같이 들어왔을 때:
```
$> ./pipex file1 cmd1 cmd2 cmd3 ... cmdn file2
```

이 shell command와 정확하게 동일한 행동을 해야 합니다:
```
< file1 cmd1 | cmd2 | cmd3 ... | cmdn > file2
```

2. **첫 번째 파라미터가 “here_doc”일 때 << 그리고 >> 커맨드를 지원해야 한다.**  
인자가 아래와 같이 들어왔을 때:

```
$> ./pipex here_doc LIMITER cmd cmd1 file
```

이 shell command와 정확하게 동일한 행동을 해야 합니다:
~~~
cmd << LIMITER | cmd1 >> file
~~~


목차
  1. 주요 기술적 이슈와 해결 과정
  2. 평가 피드백

### 1. 주요 기술적 이슈와 해결 과정  
프로젝트 진행 중 마주친 주요 문제점은 **프로세스 관리 구조**였습니다.  
자식 프로세스가 다시 새로운 자식 프로세스를 생성하는 다중 계층 구조를 채택하여 진행하였는데  
이는 다음과 같은 문제를 야기했습니다:  

- 인자로 들어온 cmd의 실행을 위해서는 자식 프로세스에서 execve 시스템 콜의 실행이 필수적
- 하지만, 자식 프로세스에서 execve 시스템 콜 실행 시 손자의 pid 정보를 상실하는 문제 발생
- 즉, 손자 프로세스는 고아 프로세스가 됨
- 이대로 진행한다면 고아 프로세스를 양산하는 프로그램이 되어버림

해결 방안  
단일 부모 프로세스가 모든 자식 프로세스를 직접 관리하는 평면적 구조로 재설계를 진행했습니다.  
프로세스 생성과 관리 책임을 부모 프로세스에 중앙화함으로써 고아 프로세스의 발생 가능성을 차단했습니다.  

개선된 결과  
중앙화된 프로세스 관리 구조를 확립하여 자식 프로세스의 생애주기를 적절히 관리하는 프로그램으로 만들 수 있었습니다.  


### 2. 평가 피드백  
<img width="639" alt="스크린샷 2024-12-29 오후 4 07 42" src="https://github.com/user-attachments/assets/f0b19978-a04b-4049-a5a4-75c4cfded1c7" />

